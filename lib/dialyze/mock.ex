defmodule Dialyze.Mock do
  def warnings do


[{:warn_matching, {'lib/comparable/datetime.ex', 25}, {:pattern_match, ['pattern _@7 = {\'ok\', _}', 'integer()']}}, {:warn_matching, {'lib/comparable/datetime.ex', 25}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', 'integer()']}}, {:warn_matching, {'lib/comparable/datetime.ex', 31}, {:pattern_match, ['pattern _@11 = {\'ok\', _}', 'integer() | {non_neg_integer(),non_neg_integer(),non_neg_integer()}']}}, {:warn_behaviour, {'lib/comparable/datetime.ex', 63}, {:callback_spec_type_mismatch, [Timex.Comparable, :diff, 3, 'integer()', 'non_neg_integer() | {\'error\',_} | {non_neg_integer(),non_neg_integer(),non_neg_integer()}']}}, {:warn_matching, {'lib/comparable/datetime.ex', 75}, {:pattern_match, ['pattern _@7 = {\'ok\', _}', 'integer()']}}, {:warn_matching, {'lib/comparable/datetime.ex', 75}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', 'integer()']}}, {:warn_matching, {'lib/comparable/datetime.ex', 103}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', '{non_neg_integer(),non_neg_integer(),non_neg_integer()}']}}, {:warn_matching, {'lib/comparable/datetime.ex', 103}, {:pattern_match, ['pattern _@2 = {\'error\', _}', '{non_neg_integer(),non_neg_integer(),non_neg_integer()}']}}, {:warn_matching, {'lib/comparable/datetime.ex', 104}, {:pattern_match, ['pattern _err@1 = {\'error\', _}', '{\'ok\',{non_neg_integer(),non_neg_integer(),non_neg_integer()}}']}}, {:warn_matching, {'lib/comparable/datetime.ex', 130}, {:pattern_match_cov, ['variable _@8', '{\'error\',_}']}}, {:warn_matching, {'lib/comparable/datetime.ex', 130}, {:pattern_match, ['pattern _@7 = {\'ok\', _}', '{\'error\',_}']}}, {:warn_matching, {'lib/comparable/datetime.ex', 130}, {:pattern_match_cov, ['variable _@4', '{\'error\',_}']}}, {:warn_matching, {'lib/comparable/datetime.ex', 130}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', '{\'error\',_}']}}, {:warn_matching, {'lib/comparable/datetime.ex', 132}, {:pattern_match_cov, ['pattern {_, _err@2 = {\'error\', _}}', '{{\'error\',_},{\'error\',_}}']}}, {:warn_matching, {'lib/comparable/datetime.ex', 133}, {:pattern_match, ['pattern {{\'ok\', _ending@1}, {\'ok\', _start@1}}', '{{\'error\',_},{\'error\',_}}']}}, {:warn_failing_call, {'lib/convert/map.ex', 38}, {:call, [Timex, :datetime, '({{_,_,_},{_,_,_,_}},tz@2::binary())', [1], :only_contract, '(any(),any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':valid_timezone()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/convert/tuple.ex', 63}, {:call, [:calendar, :datetime_to_gregorian_seconds, '(datetime@1::{{_,_,_},{_,_,_,_}})', [1], :both, '({{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()}})', 'non_neg_integer()', {true, '(DateTime) -> Seconds when is_subtype(DateTime,datetime()), is_subtype(Seconds,non_neg_integer())'}]}}, {:warn_failing_call, {'lib/convert/tuple.ex', 69}, {:call, [:calendar, :datetime_to_gregorian_seconds, '(datetime@1::{{_,_,_},{_,_,_},{_,_}})', [1], :both, '({{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()}})', 'non_neg_integer()', {true, '(DateTime) -> Seconds when is_subtype(DateTime,datetime()), is_subtype(Seconds,non_neg_integer())'}]}}, {:warn_failing_call, {'lib/convert/tuple.ex', 108}, {:call, [Timex.DateTime, :from, '(datetime@1::{{_,_,_},{_,_,_},_})', [1], :only_contract, '(any())', '{\'error\',\'badarg\' | \'invalid\' | \'invalid_date\' | \'invalid_datetime\' | {\'invalid_timezone\',_} | {\'could_not_resolve_timezone\',binary(),integer(),\'utc\' | \'wall\'}} | \#{}', {true, '(\'Elixir.Timex.Types\':valid_datetime() | \'Elixir.Timex.Types\':phoenix_datetime_select_params()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/convert/tuple.ex', 140}, {:call, [Timex.DateTime, :from, '(datetime@1::{{_,_,_},{_,_,_,_},{_,_}})', [1], :only_contract, '(any())', '{\'error\',\'badarg\' | \'invalid\' | \'invalid_date\' | \'invalid_datetime\' | {\'invalid_timezone\',_} | {\'could_not_resolve_timezone\',binary(),integer(),\'utc\' | \'wall\'}} | \#{}', {true, '(\'Elixir.Timex.Types\':valid_datetime() | \'Elixir.Timex.Types\':phoenix_datetime_select_params()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/convert/tuple.ex', 170}, {:call, [Timex.DateTime, :from, '(gregorian@1::{{_,_,_},{_,_,_},{_,_}})', [1], :only_contract, '(any())', '{\'error\',\'badarg\' | \'invalid\' | \'invalid_date\' | \'invalid_datetime\' | {\'invalid_timezone\',_} | {\'could_not_resolve_timezone\',binary(),integer(),\'utc\' | \'wall\'}} | \#{}', {true, '(\'Elixir.Timex.Types\':valid_datetime() | \'Elixir.Timex.Types\':phoenix_datetime_select_params()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_contract_types, {'lib/date/date.ex', 49}, {:invalid_contract, [Timex.Date, :epoch, 1, '(\'seconds\' | \'secs\') -> integer() | {\'error\',\'badarg\' | \'invalid_date\'}']}}, {:warn_matching, {'lib/date/date.ex', 128}, {:pattern_match_cov, ['variable _@4', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 128}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 130}, {:pattern_match, ['pattern {\'ok\', _datetime@1}', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 142}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', '\#{}']}}, {:warn_matching, {'lib/date/date.ex', 156}, {:pattern_match_cov, ['variable _@4', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 156}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 158}, {:pattern_match, ['pattern {\'ok\', _datetime@1}', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 170}, {:pattern_match_cov, ['variable _@4', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 170}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 172}, {:pattern_match, ['pattern {\'ok\', _datetime@1}', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 184}, {:pattern_match_cov, ['variable _@4', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 184}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 186}, {:pattern_match, ['pattern {\'ok\', _datetime@1}', '{\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/date/date.ex', 206}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', '\#{}']}}, {:warn_matching, {'lib/date/date.ex', 231}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', '\#{}']}}, {:warn_matching, {'lib/date/date.ex', 253}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', '\#{}']}}, {:warn_return_no_exit, {'lib/datetime/datetime.ex', 42}, {:no_return, [:only_normal, :today, 0]}}, {:warn_failing_call, {'lib/datetime/datetime.ex', 42}, {:call, [Timex, :beginning_of_day, '(\#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/datetime/datetime.ex', 43}, {:call, [Timex, :beginning_of_day, '(\#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/datetime/datetime.ex', 44}, {:call, [Timex, :beginning_of_day, '(\#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/datetime/datetime.ex', 45}, {:call, [Timex, :beginning_of_day, '(\#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/datetime/datetime.ex', 73}, {:call, [Timex.DateTime, :now, '(\'seconds\')', [1], :only_contract, '(any())', 'integer() | {\'error\',\'badarg\' | \'invalid_date\' | \'invalid_unit\' | {\'invalid_timezone\',binary()} | {\'could_not_resolve_timezone\',binary(),integer(),\'utc\' | \'wall\'}} | \#{}', {false, '(\'secs\' | \'days\') -> integer()\n    ; (\'Elixir.Timex.TimezoneInfo\':t() | \'Elixir.String\':t() | \'utc\' | \'local\') -> \'Elixir.Timex.DateTime\':t()'}]}}, {:warn_contract_types, {'lib/datetime/datetime.ex', 371}, {:invalid_contract, [Timex.DateTime, :from_timestamp, 1, '(_) -> {\'error\',\'badarg\'}']}}, {:warn_matching, {'lib/datetime/datetime.ex', 485}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', 'integer()']}}, {:warn_matching, {'lib/datetime/datetime.ex', 492}, {:pattern_match, ['pattern _@3 = {\'ok\', _}', 'integer()']}}, {:warn_failing_call, {'lib/datetime/datetime.ex', 692}, {:call, [:erlang, :div, '(total_milliseconds@1::float(),1000)', [1], :only_sig, '(integer(),integer())', 'integer()', {false, :none}]}}, {:warn_matching, {'lib/datetime/datetime.ex', 717}, {:pattern_match, ['pattern {_date@1 = {_, _, _}, _time@1 = {_, _, _}}', '{{_,_,_},{_,_,_,_}}']}}, {:warn_matching, {'lib/datetime/datetime.ex', 719}, {:pattern_match, ['pattern <_date@1 = {_, _, _}, _time@1 = {_, _, _}, \'nil\'>', '<{_,_,_},{byte(),byte(),byte()} | {_,_,_,_},\#{}>']}}, {:warn_matching, {'lib/datetime/datetime.ex', 720}, {:pattern_match, ['pattern <_date@1 = {_, _, _}, _time@1 = {_, _, _, _}, \'nil\'>', '<{_,_,_},{byte(),byte(),byte()} | {_,_,_,_},\#{}>']}}, {:warn_matching, {'lib/datetime/datetime.ex', 732}, {:pattern_match, ['pattern <_date@1 = {_, _, _}, _time@1 = {_, _, _, _}, {_, _name@1}>', '<{_,_,_},{byte(),byte(),byte()} | {_,_,_,_},\#{}>']}}, {:warn_failing_call, {'lib/datetime/inspect.ex', 9}, {:call, [Timex, :format!, '(datetime@1::\#{},<<_:352>>)', [1], :both, '(\'Elixir.Timex.Convertable\',binary())', 'no_return()', {true, '(\'Elixir.Timex.Convertable\',format::\'Elixir.String\':t()) -> \'Elixir.String\':t() | no_return()'}]}}, {:warn_failing_call, {'lib/datetime/inspect.ex', 12}, {:call, [Timex, :format!, '(datetime@1::\#{},<<_:472>>)', [1], :both, '(\'Elixir.Timex.Convertable\',binary())', 'no_return()', {true, '(\'Elixir.Timex.Convertable\',format::\'Elixir.String\':t()) -> \'Elixir.String\':t() | no_return()'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 52}, {:call, [Timex.Format.DateTime.Formatter, :lformat, '(date@1::\#{},format_string@1::binary(),locale@1::binary(),formatter@1::atom())', [1], :only_contract, '(any(),any(),any(),any())', 'any()', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.String\':t(),\'Elixir.String\':t(),atom() | \'nil\') -> {\'ok\',\'Elixir.String\':t()} | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 64}, {:call, [Timex.Format.DateTime.Formatter, :lformat!, '(d@1::\#{},format_string@1::binary(),locale@1::binary(),formatter@1::atom())', [1], :only_contract, '(any(),any(),any(),atom())', 'no_return()', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.String\':t(),\'Elixir.String\':t(),atom() | \'nil\') -> \'Elixir.String\':t() | no_return()'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 91}, {:call, [Timex.Format.DateTime.Formatter, :lformat, '(d@1::\#{},format_string@1::binary(),locale@1::binary(),formatter@1::atom())', [1], :only_contract, '(any(),any(),any(),any())', 'any()', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.String\':t(),\'Elixir.String\':t(),atom() | \'nil\') -> {\'ok\',\'Elixir.String\':t()} | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 173}, {:call, [Timex, :to_datetime, '(date@1::\#{})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 456}, {:call, [Timex, :iso_week, '(date@1::\#{})', [1], :only_contract, '(any())', '{\'error\' | non_neg_integer(),_}', {true, '(\'Elixir.Timex.Convertable\') -> {\'Elixir.Timex.Types\':year(),\'Elixir.Timex.Types\':weeknum()} | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 460}, {:call, [Timex, :iso_week, '(date@1::\#{})', [1], :only_contract, '(any())', '{\'error\' | non_neg_integer(),_}', {true, '(\'Elixir.Timex.Convertable\') -> {\'Elixir.Timex.Types\':year(),\'Elixir.Timex.Types\':weeknum()} | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 476}, {:call, [Timex, :day, '(date@1::\#{})', [1], :only_contract, '(any())', 'pos_integer() | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':daynum() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 479}, {:call, [Timex, :iso_week, '(date@1::\#{})', [1], :only_contract, '(any())', '{\'error\' | non_neg_integer(),_}', {true, '(\'Elixir.Timex.Convertable\') -> {\'Elixir.Timex.Types\':year(),\'Elixir.Timex.Types\':weeknum()} | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 483}, {:call, [Timex, :iso_week, '(date@1::\#{})', [1], :only_contract, '(any())', '{\'error\' | non_neg_integer(),_}', {true, '(\'Elixir.Timex.Convertable\') -> {\'Elixir.Timex.Types\':year(),\'Elixir.Timex.Types\':weeknum()} | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 487}, {:call, [Timex, :iso_week, '({_,12,31})', [1], :only_contract, '(any())', '{\'error\' | non_neg_integer(),_}', {true, '(\'Elixir.Timex.Convertable\') -> {\'Elixir.Timex.Types\':year(),\'Elixir.Timex.Types\':weeknum()} | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 506}, {:call, [Timex, :weekday, '(date@1::\#{})', [1], :only_contract, '(any())', '1 | 2 | 3 | 4 | 5 | 6 | 7 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':weekday() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 509}, {:call, [Timex, :weekday, '(date@1::\#{})', [1], :only_contract, '(any())', '1 | 2 | 3 | 4 | 5 | 6 | 7 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':weekday() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 516}, {:call, [Timex, :weekday, '(date@1::\#{})', [1], :only_contract, '(any())', '1 | 2 | 3 | 4 | 5 | 6 | 7 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':weekday() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/format/datetime/formatter.ex', 521}, {:call, [Timex, :weekday, '(date@1::\#{})', [1], :only_contract, '(any())', '1 | 2 | 3 | 4 | 5 | 6 | 7 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':weekday() | {\'error\',term()}'}]}}, {:warn_behaviour, {'lib/format/datetime/formatters/relative.ex', 48}, {:callback_spec_type_mismatch, [Timex.Format.DateTime.Formatter, :lformat, 3, 'binary()', '{\'error\',_} | {\'ok\',binary()}']}}, {:warn_contract_types, {'lib/format/datetime/formatters/relative.ex', 48}, {:overlapping_contract, [Timex.Format.DateTime.Formatters.Relative, :lformat, 3]}}, {:warn_matching, {'lib/format/datetime/formatters/relative.ex', 87}, {:pattern_match, ['pattern <_locale@1, _date@1, _relative@1, _, _error@1 = {\'error\', _}>', '<_,_,_,[\#{},...],bitstring()>']}}, {:warn_behaviour, {'lib/l10n/gettext.ex', 1}, {:callback_arg_type_mismatch, [Gettext.Backend, :"MACRO-dgettext", 3, 1, '{_,_}', '\#{}']}}, {:warn_behaviour, {'lib/l10n/gettext.ex', 1}, {:callback_arg_type_mismatch, [Gettext.Backend, :"MACRO-dgettext", 4, 1, '{_,_}', '\#{}']}}, {:warn_behaviour, {'lib/l10n/gettext.ex', 1}, {:callback_arg_type_mismatch, [Gettext.Backend, :"MACRO-dngettext", 5, 1, '{_,_}', '\#{}']}}, {:warn_behaviour, {'lib/l10n/gettext.ex', 1}, {:callback_arg_type_mismatch, [Gettext.Backend, :"MACRO-dngettext", 6, 1, '{_,_}', '\#{}']}}, {:warn_failing_call, {'lib/parse/datetime/parser.ex', 165}, {:call, [Timex, :century, '(\#{})', [1], :only_contract, '(any())', 'integer() | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\' | \'Elixir.Timex.Types\':year()) -> non_neg_integer() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/parse/datetime/parser.ex', 169}, {:call, [Timex, :century, '(\#{})', [1], :only_contract, '(any())', 'integer() | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\' | \'Elixir.Timex.Types\':year()) -> non_neg_integer() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/parse/datetime/parser.ex', 177}, {:call, [Timex, :to_erlang_datetime, '(\#{})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':datetime() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/parse/datetime/parser.ex', 191}, {:call, [Timex, :weekday, '(date@1::\#{})', [1], :only_contract, '(any())', '1 | 2 | 3 | 4 | 5 | 6 | 7 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':weekday() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/parse/datetime/parser.ex', 198}, {:call, [Timex, :weekday, '(date@1::\#{})', [1], :only_contract, '(any())', '1 | 2 | 3 | 4 | 5 | 6 | 7 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':weekday() | {\'error\',term()}'}]}}, {:warn_matching, {'lib/parse/datetime/parser.ex', 208}, {:pattern_match, ['pattern {_year@2, _, _weekday@1}', '{\'error\',_}']}}, {:warn_failing_call, {'lib/parse/datetime/parser.ex', 240}, {:call, [Timex, :to_erlang_datetime, '(date@1::\#{})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':datetime() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/parse/datetime/parser.ex', 243}, {:call, [Timex, :to_erlang_datetime, '(date@1::\#{})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':datetime() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/parse/datetime/parser.ex', 248}, {:call, [Timex, :to_erlang_datetime, '(date@1::\#{})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':datetime() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/parse/datetime/parser.ex', 251}, {:call, [Timex, :to_erlang_datetime, '(date@1::\#{})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':datetime() | {\'error\',term()}'}]}}, {:warn_matching, {'lib/parse/datetime/parsers/iso8601_extended.ex', 110}, {:pattern_match, ['pattern _err@1 = {\'error\', _reason@1, _count@1}', '{\'ok\',_,_,_}']}}, {:warn_behaviour, {'lib/parse/datetime/tokenizers/default.ex', 31}, {:callback_spec_type_mismatch, [Timex.Parse.DateTime.Tokenizer, :apply, 3, '{\'ok\',\#{}}', '\'unrecognized\' | {\'error\',_} | \#{}']}}, {:warn_behaviour, {'lib/parse/datetime/tokenizers/strftime.ex', 30}, {:callback_spec_type_mismatch, [Timex.Parse.DateTime.Tokenizer, :apply, 3, '{\'ok\',\#{}}', '\'unrecognized\' | {\'error\',_} | \#{}']}}, {:warn_failing_call, {'lib/time/time.ex', 213}, {:call, [Timex.Time, :from, '(float(),\'seconds\')', [1], :only_contract, '(number() | {number(),number(),number()},\'days\' | \'hms\' | \'hours\' | \'microseconds\' | \'milliseconds\' | \'mins\' | \'minutes\' | \'msecs\' | \'seconds\' | \'secs\' | \'usecs\' | \'weeks\')', '{integer(),integer(),integer()}', {true, '(integer() | \'Elixir.Timex.Types\':time(),units()) -> \'Elixir.Timex.Types\':timestamp()'}]}}, {:warn_failing_call, {'lib/timex.ex', 268}, {:call, [Timex, :lformat, '(dt@1::\#{},\#{#<123>(8, 1, \'integer\', [\'unsigned\', \'big\']), #<114>(8, 1, \'integer\', [\'unsigned\', \'big\']), #<101>(8, 1, \'integer\', [\'unsigned\', \'big\']), #<108>(8, 1, \'integer\', [\'unsigned\', \'big\']), #<97>(8, 1, \'integer\', [\'unsigned\', \'big\']), #<116>(8, 1, \'integer\', [\'unsigned\', \'big\']), #<105>(8, 1, \'integer\', [\'unsigned\', \'big\']), #<118>(8, 1, \'integer\', [\'unsigned\', \'big\']), #<101>(8, 1, \'integer\', [\'unsigned\', \'big\']), #<125>(8, 1, \'integer\', [\'unsigned\', \'big\'])}#,locale@1::binary(),\'relative\')', [1], :both, '(\'Elixir.Timex.Convertable\',binary(),binary(),atom())', '{\'error\',_} | {\'ok\',binary()}', {true, '(\'Elixir.Timex.Convertable\',format::\'Elixir.String\':t(),locale::\'Elixir.String\':t(),formatter::atom()) -> {\'ok\',\'Elixir.String\':t()} | {\'error\',term()}'}]}}, {:warn_return_no_exit, {'lib/timex.ex', 434}, {:no_return, [:only_normal, :century, 0]}}, {:warn_failing_call, {'lib/timex.ex', 434}, {:call, [Timex, :century, '({\'error\',\'invalid_date\'} | \#{})', [1], :only_contract, '(any())', 'integer() | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\' | \'Elixir.Timex.Types\':year()) -> non_neg_integer() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 520}, {:call, [Timex, :date, '(datetime@1::{integer(),_,number()})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 560}, {:call, [Timex, :iso_week, '(d@1::\#{})', [1], :only_contract, '(any())', '{\'error\' | non_neg_integer(),_}', {true, '(\'Elixir.Timex.Convertable\') -> {\'Elixir.Timex.Types\':year(),\'Elixir.Timex.Types\':weeknum()} | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 593}, {:call, [Timex, :iso_week, '(d@1::\#{})', [1], :only_contract, '(any())', '{\'error\' | non_neg_integer(),_}', {true, '(\'Elixir.Timex.Convertable\') -> {\'Elixir.Timex.Types\':year(),\'Elixir.Timex.Types\':weeknum()} | {\'error\',term()}'}]}}, {:warn_return_no_exit, {'lib/timex.ex', 609}, {:no_return, [:only_normal, :from_iso_triplet, 1]}}, {:warn_matching, {'lib/timex.ex', 612}, {:pattern_match, ['pattern {_, _, _jan4weekday@1}', '{\'error\',_}']}}, {:warn_matching, {'lib/timex.ex', 765}, {:pattern_match, ['pattern {_err@1 = {\'error\', _}, _}', '{\'false\',boolean()} | {\'true\',boolean()}']}}, {:warn_matching, {'lib/timex.ex', 766}, {:pattern_match, ['pattern {_, _err@2 = {\'error\', _}}', '{\'false\',boolean()} | {\'true\',boolean()}']}}, {:warn_failing_call, {'lib/timex.ex', 881}, {:call, [Timex, :add, '(d@1::\#{},timestamp@1::{_,_,_})', [1], :only_contract, '(any(),{_,_,_})', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':timestamp()) -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 895}, {:call, [Timex, :subtract, '(d@1::\#{},timestamp@1::{_,_,_})', [1], :only_contract, '(any(),{_,_,_})', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':timestamp()) -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1108}, {:call, [Timex, :weekday, '(d@1::\#{})', [1], :only_contract, '(any())', '1 | 2 | 3 | 4 | 5 | 6 | 7 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':weekday() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1122}, {:call, [Timex, :to_datetime, '(date@1::\#{})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1130}, {:call, [Timex, :day, '(d@1::\#{})', [1], :only_contract, '(any())', 'pos_integer() | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':daynum() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1149}, {:call, [Timex, :days_in_month, '(d@1::\#{})', [1], :only_contract, '(any())', '28 | 29 | 30 | 31 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':num_of_days() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1176}, {:call, [Timex, :week_of_month, '(d@1::\#{})', [1], :only_contract, '(any())', 'integer() | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':week_of_month()'}]}}, {:warn_failing_call, {'lib/timex.ex', 1206}, {:call, [Timex, :date, '({_,_,1})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1208}, {:call, [Timex, :datetime, '({{_,_,1},{0,0,0}},tz@1::any())', [1], :only_contract, '(any(),any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':valid_timezone()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1210}, {:call, [Timex, :datetime, '({{_,_,1},{0,0,0}})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1224}, {:call, [Timex, :date, '({_,pos_integer(),1})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1238}, {:call, [Timex, :days_in_month, '(date@1::\#{})', [1], :only_contract, '(any())', '28 | 29 | 30 | 31 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':num_of_days() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1240}, {:call, [Timex, :days_in_month, '(date@1::\#{})', [1], :only_contract, '(any())', '28 | 29 | 30 | 31 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':num_of_days() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1242}, {:call, [Timex, :days_in_month, '(date@1::\#{})', [1], :only_contract, '(any())', '28 | 29 | 30 | 31 | {\'error\',_}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Types\':num_of_days() | {\'error\',term()}'}]}}, {:warn_contract_types, {'lib/timex.ex', 1258}, {:invalid_contract, [Timex, :end_of_month, 2, '(_,_) -> {\'error\',\'invalid_year_or_month\'}']}}, {:warn_failing_call, {'lib/timex.ex', 1260}, {:call, [Timex, :date, '({non_neg_integer(),pos_integer(),1})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_matching, {'lib/timex.ex', 1274}, {:pattern_match_cov, ['pattern ~{\'month\':=_month@1, \'__struct__\':=\'Elixir.Timex.Date\'}~', 'pos_integer()']}}, {:warn_matching, {'lib/timex.ex', 1275}, {:pattern_match_cov, ['pattern ~{\'month\':=_month@1, \'__struct__\':=\'Elixir.Timex.DateTime\'}~', 'pos_integer()']}}, {:warn_matching, {'lib/timex.ex', 1276}, {:pattern_match_cov, ['variable _datetime@1', 'pos_integer()']}}, {:warn_failing_call, {'lib/timex.ex', 1294}, {:call, [Timex, :date, '({non_neg_integer(),1 | 4 | 7 | 10,1})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1300}, {:call, [Timex, :datetime, '({{non_neg_integer(),1 | 4 | 7 | 10,1},{0,0,0}},tz@1::any())', [1], :only_contract, '(any(),any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':valid_timezone()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1304}, {:call, [Timex, :datetime, '({{non_neg_integer(),1 | 4 | 7 | 10,1},{0,0,0}})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1327}, {:call, [Timex, :date, '({non_neg_integer(),3 | 6 | 9 | 12,1})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1333}, {:call, [Timex, :datetime, '({{non_neg_integer(),3 | 6 | 9 | 12,1},{0,0,0}},tz@1::any())', [1], :only_contract, '(any(),any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':valid_timezone()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1343}, {:call, [Timex, :datetime, '({non_neg_integer(),3 | 6 | 9 | 12,1})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1348}, {:call, [Timex, :end_of_quarter, '(d@1::\#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1360}, {:call, [Timex, :date, '({non_neg_integer(),3 | 6 | 9 | 12,1})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1382}, {:call, [Timex, :date, '({non_neg_integer(),1,1})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1384}, {:call, [Timex, :datetime, '({non_neg_integer(),1,1},tz@1::any())', [1], :only_contract, '(any(),any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':valid_timezone()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1386}, {:call, [Timex, :datetime, '({non_neg_integer(),1,1})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1388}, {:call, [Timex, :date, '({non_neg_integer(),1,1})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_matching, {'lib/timex.ex', 1400}, {:guard_fail_pat, ['pattern <_year@1, _tz@1 = ~{\'__struct__\':=\'Elixir.Timex.TimezoneInfo\'}~>', '<_,_>']}}, {:warn_failing_call, {'lib/timex.ex', 1403}, {:call, [Timex, :datetime, '({non_neg_integer(),1,1},tz@1::\'local\' | \'utc\' | binary() | integer())', [1], :only_contract, '(any(),any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':valid_timezone()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1425}, {:call, [Timex, :date, '({non_neg_integer(),12,31})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1427}, {:call, [Timex, :datetime, '({{non_neg_integer(),12,31},{23,59,59}},tz@1::any())', [1], :only_contract, '(any(),any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':valid_timezone()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1429}, {:call, [Timex, :datetime, '({{non_neg_integer(),12,31},{23,59,59}})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1431}, {:call, [Timex, :date, '({{non_neg_integer(),12,31},{23,59,59}})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1444}, {:call, [Timex, :datetime, '({{non_neg_integer(),12,31},{23,59,59}},tz@1::\#{})', [1], :only_contract, '(any(),any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':valid_timezone()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1446}, {:call, [Timex, :datetime, '({{non_neg_integer(),12,31},{23,59,59}},tz@1::\'local\' | \'utc\' | binary() | integer())', [1], :only_contract, '(any(),any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\',\'Elixir.Timex.Types\':valid_timezone()) -> \'Elixir.Timex.DateTime\':t() | \'Elixir.Timex.AmbiguousDateTime\':t() | {\'error\',term()}'}]}}, {:warn_contract_types, {'lib/timex.ex', 1508}, {:invalid_contract, [Timex, :days_to_end_of_week, 2, '({{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()} | {byte(),byte(),byte(),non_neg_integer()}} | {non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255} | \#{},1 | 2 | 3 | 4 | 5 | 6 | 7) -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | {\'error\',_}']}}, {:warn_return_no_exit, {'lib/timex.ex', 1509}, {:no_return, [:only_normal, :days_to_end_of_week, 1]}}, {:warn_failing_call, {'lib/timex.ex', 1509}, {:call, [Timex, :days_to_end_of_week, '(x0@1::any(),\'mon\')', [2], :only_sig, '({{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()} | {byte(),byte(),byte(),non_neg_integer()}} | {non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255} | \#{},1 | 2 | 3 | 4 | 5 | 6 | 7)', '0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | {\'error\',_}', {false, :none}]}}, {:warn_failing_call, {'lib/timex.ex', 1542}, {:call, [Timex, :beginning_of_day, '({\'error\',\'badarg\' | \'invalid\' | \'invalid_date\' | \'shift_to_invalid_date\' | {\'unknown_shift_unit\',atom()} | {\'could_not_resolve_timezone\',binary(),integer(),\'utc\' | \'wall\'}} | \#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1552}, {:call, [Timex, :beginning_of_day, '({\'error\',\'shift_to_invalid_date\' | {\'unknown_shift_unit\',atom()} | {\'could_not_resolve_timezone\',binary(),integer(),\'utc\' | \'wall\'}} | \#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1591}, {:call, [Timex, :end_of_day, '({\'error\',\'badarg\' | \'invalid\' | \'invalid_date\' | \'shift_to_invalid_date\' | {\'unknown_shift_unit\',atom()} | {\'could_not_resolve_timezone\',binary(),integer(),\'utc\' | \'wall\'}} | \#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1601}, {:call, [Timex, :end_of_day, '({\'error\',\'shift_to_invalid_date\' | {\'unknown_shift_unit\',atom()} | {\'could_not_resolve_timezone\',binary(),integer(),\'utc\' | \'wall\'}} | \#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1633}, {:call, [Timex, :beginning_of_day, '(d@1::\#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1659}, {:call, [Timex, :end_of_day, '(d@1::\#{})', [1], :only_contract, '(any())', '{\'error\',_} | \#{}', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1709}, {:call, [Timex, :datetime, '({{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()} | {byte(),byte(),byte(),non_neg_integer()}})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1711}, {:call, [Timex, :date, '({non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1713}, {:call, [Timex, :datetime, '({{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()} | {byte(),byte(),byte(),non_neg_integer()},_})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1715}, {:call, [Timex, :datetime, '({{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()} | {byte(),byte(),byte(),non_neg_integer()},\#{}})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1717}, {:call, [Timex, :datetime, '({{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()} | {byte(),byte(),byte(),non_neg_integer()},\'local\' | \'utc\' | binary() | integer()})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1719}, {:call, [Timex, :date, '({non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.Date\':t() | {\'error\',term()}'}]}}, {:warn_failing_call, {'lib/timex.ex', 1721}, {:call, [Timex, :datetime, '({{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()} | {byte(),byte(),byte(),non_neg_integer()},\#{}})', [1], :only_contract, '(any())', 'any()', {true, '(\'Elixir.Timex.Convertable\') -> \'Elixir.Timex.DateTime\':t() | {\'error\',term()}'}]}}, {:warn_contract_range, {'lib/timex.ex', 1732}, {:contract_range, ['(\'timezone\',term()) -> \'Elixir.Timex.TimezoneInfo\':t()\n    ; (\'year\' | \'month\' | \'day\' | \'hour\' | \'minute\' | \'second\' | \'millisecond\',integer()) -> integer()\n    ; (\'time\',{integer(),integer(),integer()} | {integer(),integer(),integer(),integer()}) -> \'Elixir.Timex.Types\':time()\n    ; (\'date\',{integer(),integer(),integer()}) -> {\'Elixir.Timex.Types\':year(),\'Elixir.Timex.Types\':month(),\'Elixir.Timex.Types\':day()}', Timex, :normalize, '(\'day\',{integer(),integer(),_})', 1739, 'any()']}}, {:warn_matching, {'lib/timex/helpers.ex', 29}, {:pattern_match, ['pattern \'true\'', '\'false\'']}}, {:warn_contract_types, {'lib/timezone/timezone.ex', 188}, {:overlapping_contract, [Timex.Timezone, :resolve, 3]}}, {:warn_contract_types, {'lib/timezone/timezone.ex', 265}, {:overlapping_contract, [Timex.Timezone, :convert, 2]}}, {:warn_matching, {'lib/timezone/timezone.ex', 325}, {:pattern_match, ['pattern \'milliseconds\'', '\'minutes\'']}}, {:warn_matching, {'lib/timezone/timezone.ex', 326}, {:pattern_match, ['pattern \'seconds\'', '\'minutes\'']}}, {:warn_matching, {'lib/timezone/timezone.ex', 328}, {:pattern_match, ['pattern \'hours\'', '\'minutes\'']}}, {:warn_matching, {'lib/timezone/timezone.ex', 329}, {:pattern_match, ['pattern \'days\'', '\'minutes\'']}}, {:warn_matching, {'lib/timezone/timezone.ex', 330}, {:pattern_match, ['pattern \'weeks\'', '\'minutes\'']}}, {:warn_matching, {'lib/timezone/timezone.ex', 331}, {:pattern_match_cov, ['variable _', '\'minutes\'']}}, {:warn_matching, {'lib/timezone/timezone.ex', 335}, {:guard_fail, ['unit@1::\'minutes\'', '=:=', '\'milliseconds\'']}}]

  end
end
